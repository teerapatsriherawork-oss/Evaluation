import {
  VDialogTransition
} from "./chunk-C7OYEKSR.js";
import {
  VDefaultsProvider
} from "./chunk-AL6D3P3B.js";
import {
  VOverlay,
  makeVOverlayProps
} from "./chunk-FABHZU6A.js";
import {
  useScopeId
} from "./chunk-PKWGLB3I.js";
import {
  forwardRefs
} from "./chunk-BKGZARYA.js";
import {
  useProxiedModel
} from "./chunk-3O6CMDFJ.js";
import {
  IN_BROWSER,
  focusableChildren,
  genericComponent,
  propsFactory,
  useRender
} from "./chunk-Y73U7KBF.js";
import {
  createVNode,
  mergeProps,
  nextTick,
  onBeforeUnmount,
  ref,
  watch
} from "./chunk-3B4AHPPG.js";

// node_modules/vuetify/lib/components/VDialog/VDialog.js
import "E:/personnel-evaluation/frontend/node_modules/vuetify/lib/components/VDialog/VDialog.css";
var makeVDialogProps = propsFactory({
  fullscreen: Boolean,
  retainFocus: {
    type: Boolean,
    default: true
  },
  scrollable: Boolean,
  ...makeVOverlayProps({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: VDialogTransition
    },
    zIndex: 2400
  })
}, "VDialog");
var VDialog = genericComponent()({
  name: "VDialog",
  props: makeVDialogProps(),
  emits: {
    "update:modelValue": (value) => true,
    afterEnter: () => true,
    afterLeave: () => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const overlay = ref();
    async function onFocusin(e) {
      var _a, _b, _c;
      const before = e.relatedTarget;
      const after = e.target;
      await nextTick();
      if (isActive.value && before !== after && ((_a = overlay.value) == null ? void 0 : _a.contentEl) && // We're the topmost dialog
      ((_b = overlay.value) == null ? void 0 : _b.globalTop) && // It isn't the document or the dialog body
      ![document, overlay.value.contentEl].includes(after) && // It isn't inside the dialog body
      !overlay.value.contentEl.contains(after)) {
        const focusable = focusableChildren(overlay.value.contentEl);
        (_c = focusable[0]) == null ? void 0 : _c.focus();
      }
    }
    function onKeydown(e) {
      var _a;
      if (e.key !== "Tab" || !((_a = overlay.value) == null ? void 0 : _a.contentEl)) return;
      const focusable = focusableChildren(overlay.value.contentEl);
      if (!focusable.length) return;
      const firstElement = focusable[0];
      const lastElement = focusable[focusable.length - 1];
      const active = document.activeElement;
      if (e.shiftKey && active === firstElement) {
        e.preventDefault();
        lastElement.focus();
      } else if (!e.shiftKey && active === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
    onBeforeUnmount(() => {
      document.removeEventListener("focusin", onFocusin);
      document.removeEventListener("keydown", onKeydown);
    });
    if (IN_BROWSER) {
      watch(() => isActive.value && props.retainFocus, (val) => {
        if (val) {
          document.addEventListener("focusin", onFocusin, {
            once: true
          });
          document.addEventListener("keydown", onKeydown);
        } else {
          document.removeEventListener("focusin", onFocusin);
          document.removeEventListener("keydown", onKeydown);
        }
      }, {
        immediate: true
      });
    }
    function onAfterEnter() {
      var _a;
      emit("afterEnter");
      if ((props.scrim || props.retainFocus) && ((_a = overlay.value) == null ? void 0 : _a.contentEl) && !overlay.value.contentEl.contains(document.activeElement)) {
        overlay.value.contentEl.focus({
          preventScroll: true
        });
      }
    }
    function onAfterLeave() {
      emit("afterLeave");
    }
    watch(isActive, async (val) => {
      var _a;
      if (!val) {
        await nextTick();
        (_a = overlay.value.activatorEl) == null ? void 0 : _a.focus({
          preventScroll: true
        });
      }
    });
    useRender(() => {
      const overlayProps = VOverlay.filterProps(props);
      const activatorProps = mergeProps({
        "aria-haspopup": "dialog"
      }, props.activatorProps);
      const contentProps = mergeProps({
        tabindex: -1
      }, props.contentProps);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-dialog", {
          "v-dialog--fullscreen": props.fullscreen,
          "v-dialog--scrollable": props.scrollable
        }, props.class],
        "style": props.style
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "aria-modal": "true",
        "activatorProps": activatorProps,
        "contentProps": contentProps,
        "height": !props.fullscreen ? props.height : void 0,
        "width": !props.fullscreen ? props.width : void 0,
        "maxHeight": !props.fullscreen ? props.maxHeight : void 0,
        "maxWidth": !props.fullscreen ? props.maxWidth : void 0,
        "role": "dialog",
        "onAfterEnter": onAfterEnter,
        "onAfterLeave": onAfterLeave
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": "VDialog"
          }, {
            default: () => {
              var _a;
              return [(_a = slots.default) == null ? void 0 : _a.call(slots, ...args)];
            }
          });
        }
      });
    });
    return forwardRefs({}, overlay);
  }
});

export {
  makeVDialogProps,
  VDialog
};
//# sourceMappingURL=chunk-7ZR7ZM7S.js.map
